#include <algorithm>
#include <climits>
#include <fstream>
#include <map>
#include <optional>
#include <set>
#include <sstream>

#include "lib/utils/cxxopts.hpp"
#include "lib/utils/log.h"
#include "lib/utils/string_util.h"

using filter_ret_t = std::optional<std::string>;
using address_t = uint64_t;
using addressopt_t = std::optional<address_t>;
using name_t = std::string;
using nameopt_t = std::optional<name_t>;

/*
 * This class is used to parse a symbol table given in ELF format.
 * This could look as follows:
 *  address:  flags:  section: alignment: name:
 *  00000000  l    d  .bss     00000000   .bss
 * Such a symbol table is for example generated by using 'objdump --syms
 * linux_image'. It is later used to translate gem5 output into a human readble
 * form.
 */
class SymsFilter {
 private:
  std::set<name_t> symbol_filter_;
  std::map<address_t, name_t> symbol_table_;

  std::optional<address_t> parse_address(std::string &line) {
    static std::function<bool(unsigned char)> is_address = [] (unsigned char c) {
        return std::isalnum(c) != 0;
    };

    std::string address_string = sim_string_utils::extract_and_substr_until(line, is_address);
    if (address_string.length() != 16) {
      DFLOGERR("address has not length 16, it has length %d\n",
               address_string.length());
      return std::nullopt;
    }

    char *end;
    address_t address = std::strtoull(address_string.c_str(), &end, 16);
    if (address == ULLONG_MAX) {
      DFLOGERR("Could not parse address out of hex representation '%s'\n",
               address_string.c_str());
      return std::nullopt;
    }

    return address;
  }

  void skip_fags(std::string &line) {
    sim_string_utils::trimL(line);
    // flags are devided into 7 groups
    line = line.substr(7);
  }

  void skip_section(std::string &line) {
    sim_string_utils::trimL(line);
    sim_string_utils::trimTillWhitespace(line);
  }

  void skip_alignment(std::string &line) {
    sim_string_utils::trimL(line);
    sim_string_utils::trimTillWhitespace(line);
  }

  nameopt_t parse_name(std::string &line) {
    static std::function<bool(unsigned char)> is_part_name = [] (unsigned char c) {
      return std::isalnum(c) || c == '_';
    };

    sim_string_utils::trimL(line);
    std::string name = sim_string_utils::extract_and_substr_until(line, is_part_name);

    if (name.empty()) {
        DLOGERR("could not parse non empty name\n");
        return std::nullopt;
    }

    return name;
  }

  bool add_to_sym_table(address_t address, const name_t &name) {
    auto in_set = symbol_filter_.find(name);
    if (in_set == symbol_filter_.end()) {
        DFLOGIN("filter out symbol with name '%s'\n", name.c_str());
        return false;
    }
    
    auto pair = symbol_table_.try_emplace(address, name);
    if (!pair.second) {
        DFLOGWARN("could not insert new symbol table value at address '%u'\n", address);
        return false;
    }

    return true;
  }

 public:
  SymsFilter() = default;

  /*
   * Builder function to add symbols to the symbol filter.
   * After parsing the symbol table, only those symbols are included
   * in the resulting symbol table.
   */
  inline SymsFilter &operator()(const name_t &symbol) {
    auto res = symbol_filter_.insert(symbol);
    if (!res.second) {
      DFLOGWARN("could no insert '%s' into symbol map\n", symbol.c_str());
    }
    return *this;
  }

  filter_ret_t filter(uint64_t address) {
    auto symbol = symbol_table_.find(address);
    if (symbol != symbol_table_.end()) {
      filter_ret_t(symbol->second);
    }

    return std::nullopt;
  }

  bool load_file(const std::string &file_path) {
    std::fstream infile(file_path, std::ios_base::in | std::ios_base::binary);
    if (!infile.is_open()) {
      DFLOGERR("could not open file with path '%s'\n", file_path.c_str());
      return false;
    }

    int line_number = 0;
    for (std::string line; std::getline(infile, line); line_number++) {
      DFLOGIN("found line: %s\n", line.c_str());
      sim_string_utils::trim(line);

      // parse address
      addressopt_t address_opt = parse_address(line);
      if (!address_opt.has_value()) {
        DFLOGWARN("could not parse address from line with number: %d\n",
                  line_number);
        continue;
      }
      address_t address = address_opt.value();

      // skip yet uninteresting values of ELF format
      skip_fags(line);
      skip_section(line);
      skip_alignment(line);

      // parse name
      nameopt_t name_opt = parse_name(line);
      if (!name_opt.has_value()) {
        DFLOGWARN("could not parse name from line with number: %d\n",
                  line_number);
        continue;
      }
      name_t name = name_opt.value();

      if (!add_to_sym_table(address, name)) {
        DFLOGWARN("could not insert new val '[%u] = %s' into sym table\n", address, name);
      }
    }

    return true;
  }
};

int main(int argc, char *argv[]) {
  std::string linux_dump;

  cxxopts::Options options("Tracing", "Log File Analysis/Tracing Tool");
  options.add_options()("h,help", "Print usage")(
      "linux-dump",
      "file path to a output file obtained by 'objdump --syms linux_image'",
      cxxopts::value<std::string>(linux_dump));

  try {
    cxxopts::ParseResult result = options.parse(argc, argv);

    if (result.count("help")) {
      printf("%s", options.help().c_str());
      return EXIT_SUCCESS;
    }

    if (!result.count("linux-dump")) {
      DLOGERR("could not parse option 'linux-dump'\n");
      return EXIT_FAILURE;
    }

  } catch (cxxopts::exceptions::exception &e) {
    DFLOGERR("Could not parse cli options: %s\n", e.what());
    return EXIT_FAILURE;
  }

  auto syms_filter = SymsFilter{};
  syms_filter("__tpstrtab_vector_free_moved")("__tpstrtab_vector_setup")(
      "__tpstrtab_vector_teardown")("__tpstrtab_vector_deactivate")(
      "__tpstrtab_vector_activate")("__tpstrtab_vector_alloc_managed")(
      "__tpstrtab_vector_alloc")("__tpstrtab_vector_reserve")(
      "__tpstrtab_vector_reserve_managed")("__tpstrtab_vector_clear")(
      "__tpstrtab_vector_update")("__tpstrtab_vector_config")(
      "__tpstrtab_thermal_apic_exit")("__tpstrtab_thermal_apic_entry");

  if (!syms_filter.load_file(linux_dump)) {
    DFLOGERR("could not load file with path '%s'\n", linux_dump);
    return EXIT_FAILURE;
  }

  return 0;
}