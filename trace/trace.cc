#include "lib/utils/cxxopts.hpp"
#include "lib/utils/log.h"
#include "lib/utils/string_util.h"

#include <optional>
#include <set>
#include <map>
#include <fstream>
#include <sstream>
#include <climits>

using filter_ret_t = std::optional<std::string>;
using address_t = uint64_t;
using addressopt_t = std::optional<address_t>;
using name_t = std::string;
using nameopt_t = std::optional<name_t>;

/*
 * This class is used to parse a symbol table given in ELF format. 
 * This could look as follows: 
 *  00000000 l    d  .bss   00000000 .bss
 * Such a symbol table is for example generated by using 'objdump --syms linux_image'.
 * It is later used to translate gem5 output into a human readble form.
 */
class SymsFilter {
    private:
        std::set<std::string> symbol_filter_;
        std::map<address_t, std::string> symbol_table_;

        std::optional<address_t> parse_address(std::string &line) {
            std::stringstream address_stream;
            while(line.length() != 0) {
                unsigned char letter = line[0];
                if (std::isalnum(letter) == 0) {
                    break;
                }
                address_stream << letter;
                line = line.substr(1);
            }

            std::string address_string = address_stream.str();
            DFLOGIN("address string: %s\n", address_string.c_str());
            if (address_string.length() != 16) {
                DFLOGERR("address has not length 16, it has length %d\n", address_string.length());
                return std::nullopt;
            }

            char *end;
            address_t address = std::strtoull(address_string.c_str(), &end, 16);
            DFLOGIN("address: %u\n", address);
            if (address == ULLONG_MAX) {
                DLOGERR("Could not parse address out of hex representation\n");
                return std::nullopt;
            } 

            return address;
        }

        void skip_fags(std::string &line) {}

        void skip_section(std::string &line) {}

        void skip_alignment(std::string &line) {}

        nameopt_t parse_name(std::string &line) {
            return std::nullopt;
        }

    public:
        SymsFilter() = default;

        /*
         * Builder function to add symbols to the symbol filter. 
         * After parsing the symbol table, only those symbols are included
         * in the resulting symbol table.
         */
        inline SymsFilter& operator()(const std::string &symbol) {
            auto res = symbol_filter_.insert(symbol);
            if (!res.second) {
                DFLOGWARN("could no insert '%s' into symbol map\n", symbol.c_str());
            }
            return *this;
        }


        filter_ret_t filter(uint64_t address) {
            auto symbol = symbol_table_.find(address);
            if (symbol != symbol_table_.end()) {
                filter_ret_t(symbol->second);
            }

            return std::nullopt;
        }

        bool load_file(const std::string &file_path) {
            std::fstream infile(file_path, std::ios_base::in | std::ios_base::binary);
            if (!infile.is_open()) {
                DFLOGERR("could not open file with path '%s'\n", file_path.c_str());
                return false;
            }

            int line_number = 0;
            for (std::string line; std::getline(infile, line); line_number++)
            {
                DFLOGIN("found line: %s\n", line.c_str());
                // trim space left and right
                sim_string_utils::trim(line);
                DFLOGIN("line after trim: %s\n", line.c_str());

                // parse address
                addressopt_t address_opt = parse_address(line);
                if (!address_opt.has_value()) {
                    DFLOGWARN("could not parse address from line with number: %d\n", line_number);
                }
                //address_t address = address_opt.value();
                
            }
            
            return true;
        }

};

int main(int argc, char *argv[]) {
    std::string linux_dump;

    cxxopts::Options options("Tracing", "Log File Analysis/Tracing Tool");
    options.add_options()
        ("h,help", "Print usage")
        ("linux-dump", "file path to a output file obtained by 'objdump --syms linux_image'", cxxopts::value<std::string>(linux_dump))
    ;

    try {
        cxxopts::ParseResult result = options.parse(argc, argv);

        if (result.count("help")) {
            printf("%s", options.help().c_str());
            return EXIT_SUCCESS;
        }

        if (!result.count("linux-dump")) {
            DLOGERR("could not parse option 'linux-dump'\n");
            return EXIT_FAILURE;
        }

    } catch (cxxopts::exceptions::exception &e) {
        DFLOGERR("Could not parse cli options: %s\n", e.what());
        return EXIT_FAILURE;
    }

    auto syms_filter = SymsFilter{};
    syms_filter("__tpstrtab_vector_free_moved")
        ("__tpstrtab_vector_setup")
        ("__tpstrtab_vector_teardown")
        ("__tpstrtab_vector_deactivate")
        ("__tpstrtab_vector_activate")
        ("__tpstrtab_vector_alloc_managed")
        ("__tpstrtab_vector_alloc")
        ("__tpstrtab_vector_reserve")
        ("__tpstrtab_vector_reserve_managed")
        ("__tpstrtab_vector_clear")
        ("__tpstrtab_vector_update")
        ("__tpstrtab_vector_config")
        ("__tpstrtab_thermal_apic_exit")
        ("__tpstrtab_thermal_apic_entry");

    syms_filter.load_file(linux_dump);

    return 0;
}