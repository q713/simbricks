/*
 * Copyright 2022 Max Planck Institute for Software Systems, and
 * National University of Singapore
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SIMBRICKS_TRACE_SYMS_H_
#define SIMBRICKS_TRACE_SYMS_H_

#pragma once

#define SYMS_DEBUG_

#include <algorithm>
#include <climits>
#include <fstream>
#include <map>
#include <optional>
#include <set>
#include <sstream>

#include "lib/utils/log.h"
#include "lib/utils/string_util.h"
#include "trace/reader/reader.h"

using filter_ret_t = std::optional<std::string>;
using address_t = uint64_t;
using addressopt_t = std::optional<address_t>;
using name_t = std::string;
using nameopt_t = std::optional<name_t>;

class SymsFilter {
 protected:
  std::set<name_t> symbol_filter_;

  std::optional<address_t> parse_address(std::string &line) {
    std::string address_string = sim_string_utils::extract_and_substr_until(
        line, sim_string_utils::is_alnum);
    if (address_string.length() != 16) {
#ifdef SYMS_DEBUG_
      DFLOGERR("address has not length 16, it has length %d\n",
               address_string.length());
#endif
      return std::nullopt;
    }

    char *end;
    address_t address = std::strtoull(address_string.c_str(), &end, 16);
    if (address == ULLONG_MAX) {
#ifdef SYMS_DEBUG_
      DFLOGERR("Could not parse address out of hex representation '%s'\n",
               address_string.c_str());
#endif
      return std::nullopt;
    }

    return address;
  }

  nameopt_t parse_name(std::string &line) {
    static std::function<bool(unsigned char)> is_part_name =
        [](unsigned char c) { return std::isalnum(c) || c == '_'; };

    sim_string_utils::trimL(line);
    std::string name =
        sim_string_utils::extract_and_substr_until(line, is_part_name);

    if (name.empty()) {
#ifdef SYMS_DEBUG_
      DLOGERR("could not parse non empty name\n");
#endif
      return std::nullopt;
    }

    return name;
  }

  bool add_to_sym_table(address_t address, const name_t &name) {
    auto in_set = symbol_filter_.find(name);
    if (in_set == symbol_filter_.end()) {
#ifdef SYMS_DEBUG_
      DFLOGIN("filter out symbol with name '%s'\n", name.c_str());
#endif
      return false;
    }

    auto pair = symbol_table_.try_emplace(address, name);
    if (!pair.second) {
#ifdef SYMS_DEBUG_
      DFLOGWARN("could not insert new symbol table value at address '%u'\n",
                address);
#endif
      return false;
    }

    return true;
  }

 public:
  SymsFilter() = default;

  // TODO: make private again!!!
  std::map<address_t, name_t> symbol_table_;
  /*
   * Builder function to add symbols to the symbol filter.
   * After parsing the symbol table, only those symbols are included
   * in the resulting symbol table.
   */
  inline SymsFilter &operator()(const name_t &symbol) {
    auto res = symbol_filter_.insert(symbol);
    if (!res.second) {
#ifdef SYMS_DEBUG_
      DFLOGWARN("could no insert '%s' into symbol map\n", symbol.c_str());
#endif
    }
    return *this;
  }

  /*
   * Filter function for later usage in parser. 
   * Get in address and receive label for address.
   */
  filter_ret_t filter(uint64_t address) {
    auto symbol = symbol_table_.find(address);
    if (symbol != symbol_table_.end()) {
      filter_ret_t(symbol->second);
    }

    return std::nullopt;
  }

  virtual bool load_file(const std::string &file_path) = 0;
};

/*
 * This class is used to parse a symbol table given in ELF format.
 * This could look as follows:
 *  address:  flags:  section: alignment: name:
 *  00000000  l    d  .bss     00000000   .bss
 * Such a symbol table is for example generated by using 'objdump --syms
 * linux_image'. It is later used to translate gem5 output into a human readble
 * form.
 */
class SymsSyms : public SymsFilter {
  void skip_fags(std::string &line) {
    sim_string_utils::trimL(line);
    // flags are devided into 7 groups
    line = line.substr(7);
  }

  void skip_section(std::string &line) {
    sim_string_utils::trimL(line);
    sim_string_utils::trimTillWhitespace(line);
  }

  void skip_alignment(std::string &line) {
    sim_string_utils::trimL(line);
    sim_string_utils::trimTillWhitespace(line);
  }

 public:
  SymsSyms() : SymsFilter() {
  }

  bool load_file(const std::string &file_path) override {
    LineReader reader(file_path);

    if (!reader.is_valid()) {
#ifdef SYMS_DEBUG_
      DFLOGERR("could not open file with path '%s'\n", file_path.c_str());
#endif
      return false;
    }

    for (std::string line; reader.get_next_line(line, true);) {
      DFLOGIN("found line: %s\n", line.c_str());
      sim_string_utils::trim(line);

      // parse address
      addressopt_t address_opt = parse_address(line);
      if (!address_opt.has_value()) {
#ifdef SYMS_DEBUG_
        DFLOGWARN("could not parse address from line with number: %d\n",
                  reader.ln());
#endif
        continue;
      }
      address_t address = address_opt.value();

      // skip yet uninteresting values of ELF format
      skip_fags(line);
      skip_section(line);
      skip_alignment(line);

      // parse name
      nameopt_t name_opt = parse_name(line);
      if (!name_opt.has_value()) {
#ifdef SYMS_DEBUG_
        DFLOGWARN("could not parse name from line with number: %d\n",
                  reader.ln());
#endif
        continue;
      }
      name_t name = name_opt.value();

      if (!add_to_sym_table(address, name)) {
#ifdef SYMS_DEBUG_
        DFLOGWARN("could not insert new val '[%u] = %s' into sym table\n",
                  address, name);
#endif
      }
    }
    return true;
  }

  /*
  std::ifstream infile(file_path, std::ios_base::in | std::ios_base::binary);
  if (!infile.is_open()) {
    DFLOGERR("could not open file with path '%s'\n", file_path.c_str());
    return false;
  }

  int line_number = 0;
  for (std::string line; std::getline(infile, line); line_number++) {
    DFLOGIN("found line: %s\n", line.c_str());
    sim_string_utils::trim(line);

    // parse address
    addressopt_t address_opt = parse_address(line);
    if (!address_opt.has_value()) {
      DFLOGWARN("could not parse address from line with number: %d\n",
                line_number);
      continue;
    }
    address_t address = address_opt.value();

    // skip yet uninteresting values of ELF format
    skip_fags(line);
    skip_section(line);
    skip_alignment(line);

    // parse name
    nameopt_t name_opt = parse_name(line);
    if (!name_opt.has_value()) {
      DFLOGWARN("could not parse name from line with number: %d\n",
                line_number);
      continue;
    }
    name_t name = name_opt.value();

    if (!add_to_sym_table(address, name)) {
      DFLOGWARN("could not insert new val '[%u] = %s' into sym table\n",
  address, name);
    }
  }
  */
};

class SSyms : public SymsFilter {
 public:
  SSyms() : SymsFilter() {
  }

  bool load_file(const std::string &file_path) override {
    LineReader reader(file_path);

    if (!reader.is_valid()) {
#ifdef SYMS_DEBUG_
      DFLOGERR("could not open file with path '%s'\n", file_path.c_str());
#endif
      return false;
    }

    std::string label = "";
    for (std::string line; reader.get_next_line(line, true);) {
#ifdef SYMS_DEBUG_
      DFLOGIN("found line: %s\n", line.c_str());
#endif
      sim_string_utils::trim(line);

      // parse address
      addressopt_t address_opt = parse_address(line);
      if (!address_opt.has_value()) {
#ifdef SYMS_DEBUG_
        DFLOGWARN("could not parse address from line with number: %d\n",
                  reader.ln());
#endif
        continue;
      }
      address_t address = address_opt.value();

      if (sim_string_utils::consume_and_trim_string(line, " <")) {
        nameopt_t label_opt = parse_name(line);
        if (label_opt.has_value()) {
          if (!sim_string_utils::consume_and_trim_char(line, '>')) {
            #ifdef SYMS_DEBUG_
              DFLOGERR("could not parse label from line %d, unexpected format\n", reader.ln());
            #endif
            return false;
          }
          label = label_opt.value();
        } else {
#ifdef SYMS_DEBUG_
          DFLOGERR("could not parse label from line %d\n", reader.ln());
#endif
          return false;
        }
      } else {
        if (!sim_string_utils::consume_and_trim_char(line, ':')) {
          label = "";
#ifdef SYMS_DEBUG_
        DFLOGWARN("could neiter parse label nor body addresses from line %d\n",
                  reader.ln());
#endif
        continue;
        }  
      }

      if (!add_to_sym_table(address, label)) {
#ifdef SYMS_DEBUG_
        DFLOGWARN("could not insert new val '[%u] = %s' into sym table\n",
                  address, label);
#endif
      }
    }
    return true;
  }
};

#endif  // SIMBRICKS_TRACE_SYMS_H_